(1)生成器
  当你写了个def函数里面用到yield的时候，就已经不再是一个函数了，而是一个生成器。名字变量指向的是这个生成器的算法内容。
  当你把这个生成器赋给一个变量的时候，指的是这个变量指向了这段算法的空间。所有此时并不是执行了改生成器，要执行生成器是通过迭代的方式实现的。
  其次用next的方式也可以实现使用生成器，一次next相当于迭代一次。一次迭代执行一次yield。 
  def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n      #这里用next也会使这个生成器卡在这个whileTrue的循环里。
  正常情况下如果单单执行该函数，用for循环会一直产生由3开始的所有奇数序列。
        
  def primes():
    yield 2  #第一次迭代的时候输出2
    it = _odd_iter() # 初始序列  #这只是将生成器这个算法赋给了it，it同时惰性序列（？）
    while True:
        n = next(it) # 返回序列的第一个数（？）  #用next迭代执行了该惰性序列，使其产生了该序列的下一个结果。n是下一个结果，it是包含n的序列。
        yield n   #
        it = filter(_not_divisible(n), it) # 惰性序列里如果有可以被n整除的，就把
