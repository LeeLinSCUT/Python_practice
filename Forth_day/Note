(1）模块和包
    每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的.
    否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码.
    任何模块代码的第一个字符串都被视为模块的文档注释；
    导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。
(2)sys.argv
    Sys.argv[ ]其实就是一个列表，里边的项为用户输入的参数，关键就是要明白这参数是从程序外部输入的，而非代码本身的什么地方
(3）特殊变量
    类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途
    类似_xxx和__xxx这样的函数或变量就是非公开的（private）
(4）系统变量
   if __name__ == '__main__' 的意思是：
   当 .py 文件被直接运行时，if __name__ == '__main__' 之下的代码块将被运行；
   当 .py 文件以模块形式被导入时，if __name__ == '__main__' 之下的代码块不会被运行。
   name就是标识模块的名字的一个系统变量。这里分两种情况：假如当前模块是主模块（也就是调用其他模块的模块），
   那么此模块名字就是main，通过if判断这样就可以执行“mian:”后面的主函数内容；假如此模块是被import的，
   则此模块名字为文件名字（不加后面的.py），通过if判断这样就会跳过“mian:”后面的内容。
   import的时候是要执行所import的模块的。
(5)第三方模块
  是通过包管理工具pip完成的。所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：
(6)__name__
  对主程序代码部分有时希望只让它在模块直接执行的时候才执行，被其他模块加载时就不执行。
  在Python中，可以通过系统变量_ _name_ _（注意前后都是两个下划线）的值来区分这两种情况。
  通过_ _name_ _变量的这个特性，可以将一个模块文件既可以作为普通的模块库供其他模块使用，又可以作为一个可执行文件进行执行
(7)类和实例
  class 类名（继承类名)
  类由属性和方法组成。
  如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。创建实例是通过类名+()实现的.
  可以自由地给一个实例变量绑定属性,即使该变量并没有包含在类里。
  class Student(object):
    def __init__(self, name, score):  #init参数表示创建的实例本身，self指向创建的实例本身。（感觉像是变量名）
        self.name = name
        self.score = score
(8)私有变量
   在变量前面添加__，在解释器解释的时候会把该变量换成其他的名字。
(9)继承和多态
    当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，
    总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。
    多态造成的一个结果是，任何依赖父类作为函数参数的函数。子类也可以用。
(10)方法 
      类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，
      实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
      >>> len('ABC')
      3
      >>> 'ABC'.__len__()
(11)实例属性和类属性
    实例属性是创建了实例之后绑定在实例上的属性，类属性是绑定在类身上的，归类所有，该类的所有实例都可以访问到。实例属性的优先级比类属性高。
